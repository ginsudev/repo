// Generated by CoffeeScript 2.4.1
(function() {
  // control.coffee
  // Copyright 2019 Patrick Meade.

  // This program is free software: you can redistribute it and/or modify
  // it under the terms of the GNU General Public License as published by
  // the Free Software Foundation, either version 3 of the License, or
  // (at your option) any later version.

  // This program is distributed in the hope that it will be useful,
  // but WITHOUT ANY WARRANTY; without even the implied warranty of
  // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  // GNU General Public License for more details.

  // You should have received a copy of the GNU General Public License
  // along with this program.  If not, see <https://www.gnu.org/licenses/>.
  //----------------------------------------------------------------------
  var FIELD_LINE_SPEC, isContinueLine, isFieldLine, parse, parseFieldLine, stringify, stripSignature;

  FIELD_LINE_SPEC = /^([^\s:]+):(.*)$/;

  exports.isContinueLine = isContinueLine = function(text) {
    return (text[0] === " ") || (text[0] === "\t");
  };

  exports.isFieldLine = isFieldLine = function(text) {
    return FIELD_LINE_SPEC.test(text);
  };

  exports.parse = parse = function(text) {
    var build, controlObj, field, i, len, line, lines;
    text = stripSignature(text);
    text = text.trim();
    lines = text.split("\n");
    controlObj = {};
    build = {};
    for (i = 0, len = lines.length; i < len; i++) {
      line = lines[i];
      if (isFieldLine(line)) {
        if (build.field != null) {
          controlObj[build["field"]] = build["value"];
          build = {};
        }
        field = parseFieldLine(line);
        build["field"] = field[1].trim();
        build["value"] = field[2].trimLeft();
      }
      if (isContinueLine(line)) {
        if (!Array.isArray(build["value"])) {
          build["value"] = [build["value"]];
        }
        build["value"].push(line.trim());
      }
    }
    controlObj[build["field"]] = build["value"];
    return controlObj;
  };

  exports.parseFieldLine = parseFieldLine = function(text) {
    return FIELD_LINE_SPEC.exec(text);
  };

  exports.stringify = stringify = function(obj) {
    var buffer, firstValue, i, key, len, line, ref;
    buffer = [];
    for (key in obj) {
      if (Array.isArray(obj[key])) {
        firstValue = obj[key].shift();
        if (firstValue.trim().length > 0) {
          buffer.push(`${key}: ${firstValue}`);
        } else {
          buffer.push(`${key}:`);
        }
        ref = obj[key];
        for (i = 0, len = ref.length; i < len; i++) {
          line = ref[i];
          buffer.push(` ${line}`);
        }
      } else {
        buffer.push(`${key}: ${obj[key]}`);
      }
    }
    return buffer.join("\n");
  };

  exports.stripSignature = stripSignature = function(text) {
    var i, len, line, lines, message, state, trimmed;
    // check the message for PGP signature
    trimmed = text.trim();
    lines = trimmed.split("\n");
    if (lines[0] !== "-----BEGIN PGP SIGNED MESSAGE-----") {
      return text;
    }
    // looks like we got one, so strip off the signature lines
    state = "HEADER";
    message = [];
    for (i = 0, len = lines.length; i < len; i++) {
      line = lines[i];
      if (state === "HEADER") {
        if (line.trim().length === 0) {
          state = "MESSAGE";
        }
      } else {
        if (line.trim() === "-----BEGIN PGP SIGNATURE-----") {
          break;
        } else {
          if (line.trim().length > 0) {
            message.push(line);
          }
        }
      }
    }
    // return the message part
    return message.join("\n");
  };

  //----------------------------------------------------------------------
// end of control.coffee

}).call(this);
